
#include "multiphysics.hpp"



int main(){
  // std::vector<bool> mesh_present(10000);
  // double bounds[6];
  // int mesh_geometry[3];
  // float mesh_scale[3];
  // // float translate[3] = {0};
  // import_mesh("../10x10x10_cube.stl",mesh_present,mesh_geometry,mesh_scale,bounds);

  //
  // float beam_diagnostics[BEAM_COUNT][10][] = {};
  //
  // float potentials[ELECTRODE_FIELD_MESH_X][ELECTRODE_FIELD_MESH_Y] = {};
  // bool boundary_conditions[ELECTRODE_FIELD_MESH_X][ELECTRODE_FIELD_MESH_Y] = {};
  //
  //
  // potentials[x][y] = v;
  // boundary_conditions[x][y] = 1;
  // auto start = high_resolution_clock::now();
  //
  // relax_laplace_potentials(potentials,boundary_conditions,0.1);
  //
  // auto stop = high_resolution_clock::now();
  // auto duration = duration_cast<microseconds>(stop - start);
  //
  // particle_position[2] = {0,0};
  // particle_velocity[2] = {2000,0};
  //
  // for(int beam_index = 0; beam_index < BEAM_COUNT; beam_index++){
  //   for(int beam_step = 0; beam_step < BEAM_STEPS; beam_step++){
  //
  //   }
  // }
  // // printf(lowest_diff)
  // // printf("%i%% complete\n",(int) (y/ELECTRODE_FIELD_MESH_Y)*100);
  // clear_screen();
  // printf("\x1b[38;2;255;255;0mDan's Hyper Beam Solver\n");
  // printf("\x1b[38;2;255;255;255mcur: %f, lowest: %f, v: %f x: %i y: %i\n",diff,lowest_diff,v,x,y);
  // std::cout << "Time taken by function: " << duration.count() << " microseconds\n";


    // display_potentials(potentials);
    // display_potentials(potentials);
  // display_potentials(potentials);
}
